# Testing

**Learning outcomes:**

  - Purpose of automated testing
  - Different levels of test
  - Balance: speed, fragility, coverage
  - Reiterate: reactive code needs a reactive context

## Purpose of Automated Testing {-}

> Automated testing is a test method **without much user involvement during the process**.

They increase **robustness** and **reliability** of the application when:

- The application grows
- The development team changes

They ensure that:

- Changes don't break existing code
- Bugs don't arise again
- New code is working expected

## Four levels of testing for shiny apps {-}

> You should always strive to work at the **lowest possible level** so your tests are as **fast** and **robust** as possible.

- **Non-reactive** functions
- **Server function** tests by validating the flow of reactivity.
- **JavaScript** by running the app in a background web browser.
- **App visuals** by saving screenshots of selected elements *(fragile)*.

## Testing Basic structure {-}

1. Turn your app into a package

2. Create a test file for each function
  - If you have `R/module.R`
  - `usethis::use_test()` will create `tests/testthat/test-module.R`
  
3. Create tests to check a individual properties of a function by defining one or more `expect_` functions in `test_that()`.

  - GIVEN, WHEN, THEN
  - ARRANGE, ACT, ASSERT

```r
test_that("as.vector() strips names", {
  x <- c(a = 1, b = 2)
  expect_equal(as.vector(x), c(1, 2))
})
```

## load_file example {-}

1. Create the `R/load.R`.

```r
load_file <- function(name, path) {
  ext <- tools::file_ext(name)
  switch(ext,
    csv = vroom::vroom(path, delim = ",", col_types = list()),
    tsv = vroom::vroom(path, delim = "\t", col_types = list()),
    shiny::validate("Invalid file; Please upload a .csv or .tsv file")
  )
}
```

## load_file example {-}

2. Run `usethis::use_test("load")` and complete the new `test-load.R`.

```r
test_that("load_file() handles all input types", {
  # Create sample data
  df <- tibble::tibble(x = 1, y = 2)
  path_csv <- tempfile()
  path_tsv <- tempfile()
  write.csv(df, path_csv, row.names = FALSE)
  write.table(df, path_tsv, sep = "\t", row.names = FALSE)
  
  # 1. Can it load a csv file ?
  expect_equal(load_file("test.csv", path_csv), df)
  # 2. Can it load a tsv file ?
  expect_equal(load_file("test.tsv", path_tsv), df)
  # 3. Does it give an error message for other types?
  expect_error(load_file("blah", path_csv), "Invalid file")
})
```


## load_file example {-}

You can also use the `describe()` and `it()` functions to create the `test-load.R` with better error descriptions.

```r
describe("load_file()",{

  # Create sample data
  df <- tibble::tibble(x = 1, y = 2)

  it("can load a csv file",{
    path_csv <- tempfile()
    write.csv(df, path_csv, row.names = FALSE)
    expect_equal(load_file("test.csv", path_csv), df)
  })

  it("can load a tsv file",{
    path_tsv <- tempfile()
    write.table(df, path_tsv, sep = "\t", row.names = FALSE)
    expect_equal(load_file("test.tsv", path_tsv), df)
  })

  it("gives an error message for other types",{
    expect_error(load_file("blah", path_csv), "Invalid file")
  })

})
```

```
> devtools::test()
â„¹ Testing quicktest
âœ” | F W  S  OK | Context
âœ– | 1        2 | load                                                                              
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Error (test-load.R:21:5): load_file(): gives an error message for other types
```

## Ways to run tests {-}

1. Running each line interactively at the console. 
2. Running the whole test block, expecting to see a `Test passed ðŸ˜€`.
3. Running all of the tests for the current file using `devtools::test_file()`.
4. Running all of the tests for the whole package using `devtools::test()`.

## Confirming test coverage {-}

1. Install the your current package using `devtools::install_local()`.
2. Run `devtools::test_coverage_file()` to show you've covered all your function.

![](images//21-testing/01-testing-coverage.png)

## Confirming test coverage {-}

1. Install the your current package using `devtools::install_local()`.
2. Run `devtools::test_coverage_file()` to show you've covered all your function.

![](images//21-testing/02-testing-coverage-by-line.png)


## expect_equal {-}

```r
complicated_object <- list(
  x = list(mtcars, iris),
  y = 10
)
expect_equal(complicated_object$y, 10)
```

## expect_equal {-}

- `expect_equal(x, TRUE)` -> `expect_true(x)`
- `expect_equal(x, FALSE)` -> `expect_false(x)`
- `expect_equal(x, NULL)` -> `expect_null(x)`
- `expect_equal(length(x), 10)` -> `expect_length(x, 10)`

## Relaxed expect_equal {-}

- `expect_equal(names(x), c("a", "b", "c"))` -> `expect_named(x, c("a", "b", "c"))` 
  - Which also has the `ignore.order` and `ignore.case` arguments.
  
- `expect_setequal(x, y)` tests:
  - Every value in `x` occurs in `y`
  - Every value in `y` occurs in `x`

- `expect_mapequal(x, y)` tests:
  - `x` and `y` have the same names.
  - `x[names(y)] == y`
  
## expect_error {-}

- You just need to create an error.

```r
expect_error(stop("Bye"))
```

- You can confirm if the error matches

```r
f <- function() {
  stop("Calculation failed [location 1]")
}

expect_error(f(),  "Calculation failed")
```

- We also have the functions:
  - `expect_warning()`
  - `expect_message()`
  
  
## expect_snapshot for UI functions {-}

> **Expected result is stored in a separate snapshot file**

- If we have

```r
sliderInput01 <- function(id) {
  sliderInput(id, label = id, min = 0, max = 1, value = 0.5, step = 0.1)
}

cat(as.character(sliderInput01("x")))
#> <div class="form-group shiny-input-container">
#>   <label class="control-label" id="x-label" for="x">x</label>
#>   <input class="js-range-slider" id="x" data-skin="shiny" data-min="0" data-max="1" data-from="0.5" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
#> </div>
```

## expect_snapshot for UI functions {-}

> **Expected result is stored in a separate snapshot file**

- If we can also test

```r
test_that("sliderInput01() creates expected HTML", {
  expect_equal(as.character(sliderInput01("x")), "<div class=\"form-group shiny-input-container\">\n  <label class=\"control-label\" id=\"x-label\" for=\"x\">x</label>\n  <input class=\"js-range-slider\" id=\"x\" data-skin=\"shiny\" data-min=\"0\" data-max=\"1\" data-from=\"0.5\" data-step=\"0.1\" data-grid=\"true\" data-grid-num=\"10\" data-grid-snap=\"false\" data-prettify-separator=\",\" data-prettify-enabled=\"true\" data-keyboard=\"true\" data-data-type=\"number\"/>\n</div>")
})
#> Test passed ðŸ˜€
```

**But it makes too hard to see if the output changes**


## expect_snapshot for UI functions {-}

- Use `expect_snapshot()` to capture the output displayed on the console.

```r
test_that("sliderInput01() creates expected HTML", {
  expect_snapshot(sliderInput01("x"))
})
```

## expect_snapshot for UI functions {-}

- If your test is in `tests/testthat/test-slider.R`, it will save the output in `tests/testhat/_snaps/slider.md`

```md
# sliderInput01() creates expected HTML

    Code
      sliderInput01("x")
    Output
      <div class="form-group shiny-input-container">
        <label class="control-label" id="x-label" for="x">x</label>
        <input class="js-range-slider" id="x" data-skin="shiny" data-min="0" data-max="1" data-from="0.5" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
      </div>
```

- If itâ€™s a deliberate change, **update the snapshot by running** `testthat::snapshot_accept()`.

## Testing Reactivity

[Release 0.5](https://github.com/russHyde/er-injuries-sandpit/tree/0.5-reactive-update)

- Reactivity tests require:
  - a server (the thing that runs); and
  - a server function (the thing that's ran)
- Tests require data
  - we don't want to use the data for the main app

Structural changes:

- extract server function from `er_app`
- pass datasets (`injuries`, `products`, `population`) into the server as arguments

But this wasn't so simple

- server functions take arguments `input`, `output`, `session`
- how do we pass data into them?

### Restructured app

```
er_app <- function() {
  # `injuries`, `products` and `population` are package-hosted datasets
  # They can be accessed by name (but R CMD check complains about you referring to undefined vars)
  injuries <- get("injuries")
  products <- get("products")
  population <- get("population")

  ui <- er_ui(products = products)

  server <- make_er_server(
    injuries = injuries, products = products, population = population
  )

  shiny::shinyApp(ui, server)
}

er_ui <- function(products) {...}

make_er_server <- function(injuries, products, population) {
  function(input, output, session) {
    selected <- reactive({...})

    output$diag <- renderTable(...)
    output$body_part <- renderTable(...)
    output$location <- renderTable(...)

    summary <- reactive({...})

    output$age_sex <- renderPlot({...})
  }
}
```

### `shiny::testServer`

  - `shiny::testServer(my_server_fn, {given__when__then}, args, session)`
    - sets up reactive context for shiny (server logic) tests
    - use `args` to pass in args required in module-server
  - `session` methods:
    - `session$setInputs(...)`
      - sets input values for use in testServer tests
      - all inputs start as NULL (regardless of UI defaults)
    - `session$flushReact()`
      - setting a value doesn't auto-update the reactive graph
      - this function forces the reactive graph to update
    - `session$getReturned()`
      - to assess the value returned by a module
    - `session$elapse(millis = 300)`
      - advance the time

### A typical reactivity test

```
test_that("it updates tables when product-code changes", {
  # define test-data
  test_injuries <- tibble::tibble(...)
  test_products <- tibble::tibble(...)
  test_population <- tibble::tibble(...)

  # pass test-data into the server function
  server <- make_er_server(
    injuries = test_injuries,
    products = test_products,
    population = test_population
  )

  # check that the 'selected' table updates correctly
  testServer(
    server,
    {
      # no injuries with this code are present in the test data
      
      session$setInputs(code = 2345)

      expect_equal(
        selected(),
        test_injuries[integer(0), ]
      )

      # the first and third entries in the injuries table have this code

      session$setInputs(code = 1234)

      expect_equal(
        selected(),
        test_injuries[c(1, 3), ]
      )
    }
  )
})
```

## Testing Reactivity: Module version

Testing the server function for a module is similar to for an app's server function

- But you can pass in arguments

### Structural changes

[Release 0.6](https://github.com/russHyde/er-injuries-sandpit/tree/0.6-reactive-module/)

- Need to define a module first

UI before the change:

```
er_ui <- function(products) {
  prod_codes <- ...

  ui <- fluidPage(
    ...,
    # TODO: replace with `count_tables_ui()`
    fluidRow(
      column(4, tableOutput("diag")),
      column(4, tableOutput("body_part")),
      column(4, tableOutput("location"))
    ),
    ...
  )

  ui
}
```

Server before the change:

```
make_er_server <- function(injuries, products, population) {
  function(input, output, session) {
    ...
    selected <- reactive({...})

    # TODO: replace with `count_tables_server(selected)`
    output$diag <- renderTable(
      count_by_weight(selected(), "diag")
    )
    output$body_part <- renderTable(
      count_by_weight(selected(), "body_part")
    )
    output$location <- renderTable(
      count_by_weight(selected(), "location")
    )

    ...
  }
}
```

Introduced a module to create / render / format the count-tables:

```
count_tables_ui <- function(id) {
  ns <- NS(id)
  fluidRow(
    column(4, tableOutput(ns("diag"))),
    column(4, tableOutput(ns("body_part"))),
    column(4, tableOutput(ns("location")))
  )
}

count_tables_server <- function(id, selected) {
  stopifnot(is.reactive(selected))

  moduleServer(id, function(input, output, session) {
    diag <- reactive(
      count_by_weight(selected(), "diag")
    )
    output$diag <- renderTable(diag())

    body_part <- reactive(
      count_by_weight(selected(), "body_part")
    )
    output$body_part <- renderTable(body_part())

    location <- reactive(
      count_by_weight(selected(), "location")
    )
    output$location <- renderTable(location())
  })
}
```

### A typical module-reactivity test

```
test_selected <- tibble::tibble(...)

expected_diag <- tibble::tibble(...)

test_that("tables display the counts correctly", {
  rx_selected <- reactive(test_selected)

  testServer(count_tables_server, args = list(selected = rx_selected), {
    expect_equal(
      diag(),
      expected = expected_diag
    )
    ...
  })
})
```

## Testing JavaScript

  - JS doesn't work in testServer, because there's no front-end in testServer
  - Lot's of functions used in the `server()` require JS (eg, `insertUI`)
  - Need a browser for this
  - 'headless' (can use a browser without manual-interaction)
  - tools: `shinytest` (also puppeteer, selenium)
  
- Issues
  - Slloooooowwww
  - How to set up test-environment? (eg, custom databases)
  - Flaky code? What if the html IDs change
  - Can't see internal state

### `shinytest::ShinyDriver`

  - Example: a reset button and updateTextInput
  - `app <- shinytest::ShinyDriver(my_app())`
  - `app$setInput(name = "value")`
  - `app$getValue("name")`
  - `app$sendKeys(name, keys)`
  - `app$click("someID")`

### Exercise for the reader

What structural changes might be needed to use ShinyDriver-based end-to-end tests with the app?

- how do you pass in test data?

## New testthat things mentioned in the chapter

  - `expect_named(x, c("a", "b", "c"), ignore.order = TRUE, ignore.case = FALSE)`
  - `expect_setequal(x, y)`
  - `expect_mapequal(x, y)`
  - `expect_snapshot()`
    - Example: output for a UI function
    - Expected value is stored in a file
    - Update the expected value using `testthat::snapshot_accept()`

## New RStudio mentioned in the chapter

  - Add keyboard shortcuts:
    - This did not work
  - Shortcuts I hoped to add:
    - [Ctrl + T] : `devtools::test_file()`
    - [Ctrl + Shift + R] : `devtools::test_coverage()`
    - [Ctrl + R] : `devtools::test_coverage_file()`

  - Did anyone manage to do this?
  

## Discussions

  - Don't test the framework!
  - Don't test too early! Or do!
  - Testing religions / approaches
    - TDD: Test-driven development
    - BDD: Behaviour-driven development
    - TCR: Test && Commit || Revert


## Example

For this chapter, there is a sandpit [project on github](https://github.com/russHyde/er-injuries-sandpit)

It is copied from the ER-injuries case-study app in Chapter 4 of Mastering Shiny.

If you follow the tagged-releases it shows how to:

- Start with a working app
- Turn it into a package
- Make the package pass `R CMD check`
- Add tests for a non-reactive function
- Add a reactivity test for an app's server-function
- Add a reactivity test for a module's server-function

In order to do each step, several structural changes to the app had to be made.
Notes on how the app was modified and the tools that helped are in the README.

We'll start from a release that is a package, and passes `R CMD check` (aside from one issue re the
size of the dataset that is embedded in the package)
[Release 0.2](https://github.com/russHyde/er-injuries-sandpit/tree/480851db355f0eb39c59ae91a398a62748d86ac5)

To run the app, you run `er_app()`


## Other interesting things

- [Shinytest2 Vs Cypress: End-To-End (E2E) Testing In Shiny](https://www.appsilon.com/post/shinytest2-vs-cypress-e2e-testing)

- one of the {tinytest} vignettes has
  ["a few tips on packages and unit testing"](
    https://cran.r-project.org/web/packages/tinytest/vignettes/using_tinytest.pdf
  )
- two nice visualisations of
  [the TDD cycle](https://www.obeythetestinggoat.com/book/chapter_philosophy_and_refactoring.html#simple-TDD-diagram),
  and of
  [TDD-until-the-feature's ready](https://www.obeythetestinggoat.com/book/chapter_philosophy_and_refactoring.html#Double-Loop-TDD-diagram)
  are in "Test-Driven Development with Python" by Harry Percival.
- ["R Packages"](https://r-pkgs.org/tests.html) has a chapter about "testthat"
- The RStudio "shiny" website has
  [three  articles / webinars](https://shiny.rstudio.com/articles/testing-overview.html)
  on testing in shiny
- chapter-section on testing in
  ["Engineering Production-Grade Shiny Apps"](https://engineering-shiny.org/build-yourself-safety-net.html#testing-your-app)


## Meeting Videos

### Cohort 1

`r knitr::include_url("https://www.youtube.com/embed/8ZTGDbH1MaE")`

### Cohort 2

`r knitr::include_url("https://www.youtube.com/embed/nwAg54rA3xs")`

<details>
  <summary> Meeting chat log </summary>
  
```
00:08:40	collinberke:	https://github.com/collinberke/ga4WebDash
00:43:42	Kevin Gilds:	https://rich-iannone.github.io/pointblank/
00:50:43	Kevin Gilds:	https://github.com/yonicd/covrpage
```
</details>

`r knitr::include_url("https://www.youtube.com/embed/eguok48Piyg")`


### Cohort 3

`r knitr::include_url("https://www.youtube.com/embed/MNf6w_FpxVw")`

<details>
  <summary>Meeting chat log</summary>
```
00:28:35	Oluwafemi Oyedele:	https://github.com/collinberke/ga4WebDash
00:58:38	Oluwafemi Oyedele:	https://adv-r.hadley.nz/names-values.html#gc
```
</details>


### Cohort 4

`r knitr::include_url("https://www.youtube.com/embed/7Uz0Mh2gMfk")`

<details>
  <summary>Meeting chat log</summary>
```
00:10:54	Trevin Flickinger:	start
00:12:01	Trevin Flickinger:	https://rstudio-conf-2022.github.io/build-tidy-tools/
00:12:19	Trevin Flickinger:	https://rstudio-conf-2022.github.io/build-tidy-tools/materials/day-1-session-3-testing.html#/title-slide
00:21:47	Trevin Flickinger:	https://r-pkgs.org/index.html
00:27:17	Matthew Efoli:	thank you
00:42:42	Trevin Flickinger:	https://github.com/rstudio-conf-2022/ussie
01:04:39	Trevin Flickinger:	stop
```
</details>


### Cohort 5

`r knitr::include_url("https://www.youtube.com/embed/URL")`

<details>
  <summary>Meeting chat log</summary>
```
LOG
```
</details>
