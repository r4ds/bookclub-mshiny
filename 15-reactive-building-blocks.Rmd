# Reactive Building Blocks

**Learning Objectives**

- Building blocks:
  - Reactive values
  - Reactive expressions
  - Observers

- How these tools are built from low-level functions:
  - `observe()`
  - `isolate()`
  
- How error messages / signal conditions move on reactive graph

- Shiny reactive values are built on reference-semantics

## Types of Reactive Values {-}

|     |**reactiveVal()**|**reactiveValues()**|
|:----|:----------------|:-------------------|
|Holds|A **single** reactive value|A **list** of reactive values|
|Definition|`x <- reactiveVal(1)`|`x <- reactiveValues(a = 1, b = 2)`|
|Getting syntax|`x()`|`x$a`|
|Setting syntax|`x(2)`|`x$a <- 2`|
|Class|reactiveVal reactive function|reactivevalues|

## Copy-on-modify Semantics {-}

If you create an object with some value.

```{r}
x1 <- 10
```

And you copy the same value on a new object.

```{r}
x2 <- x1
```

## Copy-on-modify Semantics {-}

Then if you modify the original object.

```{r}
x2 <- 20
```

That won't change the value of the original object.

```{r}
x1
```


## Copy-on-modify Semantics {-}

If we create a list.

```{r}
x <- list(a = 1, b = 1)
```

And a function to modify the element "a" of the list.

```{r}
f <- function(x) {
  x$a = 2
  invisible(x)
}
```

## Copy-on-modify Semantics {-}

After applying the function to the original list will return a new object.

```{r}
f(x) |> unlist()
```

Rather than modifying the original list.

```{r}
x |> unlist()
```

## Reference Semantics (shiny) {-}

If you are working in the server function of the app.

```{r}
library(shiny)

reactiveConsole(TRUE)
```

You can copy the value of a reactive value to new object.

```{r}
b1 <- reactiveValues(x = 10)

b2 <- b1
```

But if you change the original reactive variable.

```{r}
b1$x <- 20
```

Then the copy also changes.

```{r}
b2$x
```

## Reference Semantics (R6) {-}

If you create a new object R6 object.

```{r}
y1 <- R6::R6Class("Y", list(a = 1, b = 1))$new()
```

An you copy that object.

```{r}
y2 <- y1
```

## Reference Semantics (R6) {-}

Then if you modify the value of the new object.

```{r}
y2$b <- 2
```

Then the original object also changes.

```{r}
y1 |> unlist()
```

## Reference Semantics (R6) {-}

If a function changes the value of the original object.

```{r}
f(y1)
```

Then the copy also get changed.

```{r}
y2
```

## Exercises {-}

1. *What are the differences between these two lists of reactive values? Compare the syntax for getting and setting individual reactive values.*

```{r}
# Defining values
l1 <- reactiveValues(a = 1, b = 2)
l2 <- list(a = reactiveVal(1), b = reactiveVal(2))
# ... with a little extra
l3 <- reactiveVal(list(a = 1, b = 2))
```

```r
# Getting
l1$a; l1[["a"]]
l2$a(); l2[["a"]]()
l3()$a; l3()[["a"]]

# Setting
l1$a <- 15
l2$a(15)
# For l3, can't easily update just 'a'
l3(list(a = 15, b = 2))
```

## Exercises {-}

2. *Design and perform a small experiment to verify that reactiveVal() also has reference semantics.*

```{r}
# If we define 3 objects
x <- reactiveVal(1)
y <- x
z <- reactiveVal(1)

# If we change the value of x
x(2)

# Then y also changes
x()
y()

# But z keeps the same
z()
```

## Cached Errors in Reactive Expressions {-}

Errors are **cached** just as values.

```{r, eval=FALSE}
r <- reactive(stop("Error occured at ", Sys.time(), call. = FALSE))
r()
```

```{r, echo=FALSE}
r <- reactive(stop("Error occured at ", Sys.time(), call. = FALSE))
try(r())
```

So if you run it again, it **won't update** the message.

```{r, eval=FALSE}
Sys.sleep(2)
r()
```

```{r, echo=FALSE}
Sys.sleep(2)
try(r())
```

## Propagated Errors in Reactive Expressions {-}

Errors are **propagated** through the reactive graph just as values, but they present different behavior when they reach an:

- **Output**: The error will be displayed in the app.
- **Observer**: The error will cause the current session to terminate.
  - This can be avoided by wrapping the code in `try()` or `tryCatch()` functions.

*From: examples/15-reactive-blocks/01-error-propagated-example.R*

```{r}
#| echo: true
#| eval: false
#| file: examples/15-reactive-blocks/01-error-propagated-example.R
```

## Errors in `seq()` {-}

If some error is present in next function:

- Observers and outputs to **stop what they’re doing** but not otherwise fail.
- By default, it will cause outputs to reset to their **initial blank state**, unless `req(..., cancelOutput = TRUE)` they’ll preserve their current display.

*From: examples/15-reactive-blocks/02-seq-error-example.R*

```{r}
#| echo: true
#| eval: false
#| file: examples/15-reactive-blocks/02-seq-error-example.R
```


### `on.exit()`

Where else do you see `on.exit()`?

- inside [function bodies](https://adv-r.hadley.nz/functions.html#on-exit) (eg, close this file once
the function completes, reset the plotting options after making this graph)
- in [testthat expressions](https://www.tidyverse.org/blog/2020/04/self-cleaning-test-fixtures/)

In functions, for example, the code in `on.exit()` runs after all the rest of the code has run.
It runs even if there are errors / warnings.
You can have multiple calls to `on.exit()` inside a function (use add = TRUE, so a call doesn't overwrite an earlier one)

The expression in the definition of a `reactive` can be thought of as a function body (but with
automatic caching / laziness):

```r
# Think of this:
reactive({
  do_something(x(), y())
})
# or eventReactive(triggers, {do_something(x(), y())})

# Like this:
function() {
  do_something(x(), y())
}
```

Because that's basically what it is:

```{r}
# note that `fun <- as_function(x)` line ...
reactive
```


## Observers and Outputs

Reactives : cached and lazy

Observers / Outputs : forgetful and eager

Why does `x()` never run here?

```r
server <- function(input, output, session) {
  x <- reactive({
    rnorm(10)
  })
}
```

In the reactive graph, observers and outputs are the terminal nodes.
If they were lazy, nothing would get done.

Eagerness is infectious

Observer:

- side-effect node (eg, write to file, send messages to console)
- usually defined using `observeEvent()`

Output:

- as assigned to `output$x <- ...` variable

Both created using low-level function `observe()`

```r
# observers are eager

y <- reactiveVal(10)
observe({
  message("`y` is ", y())
})
y(5)
y(4)
```

`observe()` doesn't do something, it creates something

```r
# example from the book (I found this a bit confusing)
x <- reactiveVal(1)
y <- observe({
  x()
  observe(print(x()))
})
x(2)
x(3)

# y() reacts each time x() updates
# each time y() reacts it adds a new observer node that reacts to x()
```

```r
# alternative example:
# each time you change f, a new observer of g is added to the graph
f <- reactiveVal(1)
g <- reactiveVal(2)
h <- observe({
  f()
  observe(print(g()))
})
```

## Isolating Code

`observeEvent()` and `eventReactive` allow you to access values in a reactive without taking a
reactive dependency on them.

How would you write a function to achieve that?

From section 3.5.2

```r
ui <- fluidPage(
  fluidRow(
    column(3, 
      numericInput("lambda1", label = "lambda1", value = 3),
      numericInput("lambda2", label = "lambda2", value = 5),
      numericInput("n", label = "n", value = 1e4, min = 0),
      actionButton("simulate", "Simulate!")
    ),
    column(9, plotOutput("hist"))
  )
)

server <- function(input, output, session) {
  # x1 depends on `simulate`, `n` and `lambda1`
  # ... but only has a "reactive dependency" on `simulate`
  # ... sorry, ... what?
  
  x1 <- eventReactive(input$simulate, {
    rpois(input$n, input$lambda1)
  })
  x2 <- eventReactive(input$simulate, {
    rpois(input$n, input$lambda2)
  })

  output$hist <- renderPlot({
    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))
  }, res = 96)
}
```

So we've got

```r
new_reactive <- eventReactive(dependOnThis, runThis)
```

`isolate(expression)` is used.

- separates access from dependency
- executes the expression in a scope where the reactive values can be read (see `? isolate`)
- reduces the time the reactive graph is invalidated

Counting example from the book:

```r
r <- reactiveValues(count = 0, x = 1)
observe({
  r$x
  # without the isolate() call, an infinite loop would occur
  r$count <- isolate(r$count) + 1
})

r$x <- 1
r$x <- 2
r$count
```

In `eventReactive(dependOnThis, runThis)`,
if you follow the code:
- eventReactive calls `bindEvent()`
- bindEvent (basically) calls `reactive({dependOnThis; isolate(runThis)})`

So 
- eventReactive(x, y) ===~ reactive(x, isolate(y))
- (and similarly) observeEvent(x, y) ===~ observe({x, isolate(y)})

## Timed Invalidation

In section 3.5.1

```r
server <- function(input, output, session) {
  # timer is invalidated every 500ms
  # A) How is that possible?
  timer <- reactiveTimer(500)
  
  x1 <- reactive({
    # ... hence, a new x1 and x2 are sampled each 500ms
    # B) What if sampling x1 took longer than 500ms?

    timer()
    rpois(input$n, input$lambda1)
  })
  x2 <- reactive({
    timer()
    rpois(input$n, input$lambda2)
  })
  
  output$hist <- renderPlot({
    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))
  }, res = 96)
}
```

`invalidateLater(ms)` allows the programmer to invalidate a node in the graph

```r
# Example, add a new random number to a sum once every 300ms

sum <- reactiveVal(0)
observe({
  invalidateLater(300)
  sum(isolate(sum()) + runif(1))
})
```

Note that `invalidateLater` runs from the time it is invoked.
Combine it with on.exit() to ensure the node is invalidated a fixed-time after the node's
computation completes

```r
# e.g.: iterate: load a file, one second after you finished reading it

data <- reactive({
  on.exit(invalidateLater(1000))
  read.csv("data.csv")
})
```

Additional tools `reactivePoll` and `reactiveFileReader` are built on invalidateLater

Beware, the accuracy of timing may be affected by other processes


## Meeting Videos

### Cohort 1

`r knitr::include_url("https://www.youtube.com/embed/uwawZNrU-5k")`

<details>
  <summary> Meeting chat log </summary>
  
```
01:04:02	Andrew MacDonald:	I’m afraid i ahve to duck out early today. Please let me know if we still need somebody for next week!
01:04:09	Andrew MacDonald:	thanks so much Russ et al! :D
01:04:18	docksbox@pm.me:	thanks
01:04:40	docksbox@pm.me:	are there any example apps ?
01:11:12	Layla Bouzoubaa:	Thanks russ! Need to hop off!
01:14:19	Anne Hoffrichter:	Thanks Russ! See you next week!
01:14:34	russ:	Bye
```
</details>

### Cohort 2

`r knitr::include_url("https://www.youtube.com/embed/q2d3uBHO3Tk")`

<details>
  <summary> Meeting chat log </summary>
  
```
00:37:01	Ryan Metcalf:	Really good topic on Linked List in C++. The discussion was related to memory management. https://www.geeksforgeeks.org/data-structures/linked-list/
00:45:12	Kevin Gilds:	Reactive Values in Modules
00:45:39	Kevin Gilds:	The inputs across across modules
00:47:27	Kevin Gilds:	I will put some articles in the slack reactive values and modules
```
</details>


### Cohort 3

`r knitr::include_url("https://www.youtube.com/embed/JPDAWd4Pi7U")`

<details>
  <summary>Meeting chat log</summary>
```
00:22:46	Brendan Lam:	Nope 🙁
00:24:41	Federica Gazzelloni:	more info here: https://engineering-shiny.org/common-app-caveats.html?q=R6#using-r6-as-data-storage
00:29:07	Federica Gazzelloni:	video: https://www.youtube.com/watch?v=JkacZOrB1QY&list=PL3x6DOfs2NGh-XM69f20HXT7QXCuQPZxB&index=12
01:06:16	Federica Gazzelloni:	https://shiny.rstudio.com/reference/shiny/1.3.0/reactiveVal.html
01:12:11	Brendan Lam:	my wifi was unstable so ill have to go back and rewatch some of this, but thank you Lucy for presenting!
01:12:27	Brendan Lam:	Bye!
```
</details>


`r knitr::include_url("https://www.youtube.com/embed/FGexkKxQ_wA")`

<details>
  <summary>Meeting chat log</summary>
```
00:10:15	LUCIO ENRIQUE CORNEJO RAMÍREZ:	Hi, it's Lucio :)
00:35:24	Federica Gazzelloni:	https://shiny.rstudio.com/articles/isolation.html
00:40:59	Federica Gazzelloni:	that’s nice: https://shiny.rstudio.com/gallery/isolate-demo.html
00:41:13	Federica Gazzelloni:	let's see how it does
00:50:45	Oluwafemi Oyedele:	Thank you!!!
00:50:59	LUCIO ENRIQUE CORNEJO RAMÍREZ:	Thanks!
```
</details>


### Cohort 4

`r knitr::include_url("https://www.youtube.com/embed/BiliSGguMAk")`

<details>
  <summary>Meeting chat log</summary>
```
00:03:22	Matthew:	Hi everyone,
We will start in 7 - 10 mins.
00:03:35	Lydia Gibson:	Hello
00:03:53	Matthew:	Hello
00:07:03	Lydia Gibson:	We need to update the dates on the volunteers sheet. I most likely won’t be able to attend on 5/16 so I’m not sure which chapter to sign up to present next
00:07:19	Lucio Cornejo:	Hello
00:07:24	Lydia Gibson:	Hello
00:07:55	Matthew:	Hello
00:10:05	Lucio Cornejo:	hi matthew
00:10:38	Lucio Cornejo:	Hello Trevin
00:11:30	Lucio Cornejo:	Hello Matthew
00:48:59	Lydia Gibson:	Ntd for another meeting. See you all next week!
00:55:35	Lucio Cornejo:	Thanks for the presentation. See you, everyone
```
</details>


### Cohort 5

`r knitr::include_url("https://www.youtube.com/embed/URL")`

<details>
  <summary>Meeting chat log</summary>
```
LOG
```
</details>
