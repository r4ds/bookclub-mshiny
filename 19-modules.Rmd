# Shiny modules

https://github.com/deepshamenghani/Demystifying_Shiny_modules
https://github.com/hypebright/shinyconf2024-shiny101

Functions work well if:

- All code is on the server side
- All code in on the client side

<br>

If the **server code relies** on specific structure in the **UI**

- Use **modules**

## Without modules {-}

We can end creating a really hard to mantain app.

![](images/19-modules/01-before-modules.png){width=50% height=50%}

## Modules benefits {-}

Modules are a kind of **miniature app** within a larger app that isolate a particular group of **inputs and outputs** with a UI and a server part. 

- Avoid namespace collisions
- Allows encapsulate distinct app components
- Facilities collaboration

- **Modules works as functions for Shiny**.
  - Helps you break your big, complex app into smaller parts. 
  - Makes Shiny code more readable.
  - Makes Shiny code easier to debug.
  - Makes Shiny components reusable.
  - Opens the possibility to apply unit test.
  
  
## After implementing modules {-}

![](images/19-modules/02-after-modules.png){width=50% height=50%}


## Simple histogram app {-}

```{r, eval=FALSE}
ui <- fluidPage(
  selectInput("var", "Variable", names(mtcars)),
  numericInput("bins", "bins", 10, min = 1),
  plotOutput("hist")
)
server <- function(input, output, session) {
  data <- reactive(mtcars[[input$var]])
  output$hist <- renderPlot({
    hist(data(), breaks = input$bins, main = input$var)
  }, res = 96)
}
```

## Creating UI function {-}

1. Create a function with the `id` argument.
2. Wrap all components in the `tagList` function to **bundle together multiple components** without actually implying how they’ll be laid out. 
3. Wrap each `inputId` using the next structure `NS(id, "id_name")`.

```{r, eval=FALSE}
histogramUI <- function(id) {
  tagList(
    selectInput(NS(id, "var"), "Variable", choices = names(mtcars)),
    numericInput(NS(id, "bins"), "bins", value = 10, min = 1),
    plotOutput(NS(id, "hist"))
  )
}
```

## Using NS once {-}

From `shiny::NS()` documentation.

> If id is missing, returns a function that expects an id string as its only argument and returns that id with the namespace prepended. 

```{r eval=FALSE}
histogramUI <- function(id) {
  ns <- NS(id)
  tagList(
    selectInput(ns("var"), "Variable", choices = names(mtcars)),
    numericInput(ns("bins"), "bins", value = 10, min = 1),
    plotOutput(ns("hist"))
  )
}
```

## Module server {-}

1. Create a function with the ID argument.
2. Call the `shiny::moduleServer()` and pass the id and a **function that looks like a regular server function**.

**Note:** Thanks to that `id` the `shiny::moduleServer()` will be able to bring the **inputs** and **outputs** created in the UI function.

```{r eval=FALSE}
histogramServer <- function(id) {
  moduleServer(id, function(input, output, session) {
    data <- reactive(mtcars[[input$var]])
    output$hist <- renderPlot({
      hist(data(), breaks = input$bins, main = input$var)
    }, res = 96)
  })
}
```


## Confirm that the model works {-}

We can create a custom function to validate that each modele is working.

```{r eval=FALSE}
histogramApp <- function() {
  ui <- fluidPage(
    histogramUI("hist1")
  )
  server <- function(input, output, session) {
    histogramServer("hist1")
  }
  shinyApp(ui, server)  
}
```

## Modules isolation {-}

- `output$out` will never get updated because there is no input$bins
- The bins input can only be seen inside of the **hist1 module**.


```{r eval=FALSE}
ui <- fluidPage(
  histogramUI("hist1"),
  textOutput("out")
)
server <- function(input, output, session) {
  histogramServer("hist1")
  output$out <- renderText(paste0("Bins: ", input$bins))
}
```



## Modules conventions {-}

- `R/histogram.R` holds all the code for the module.

- `histogramUI()` is the module UI. If it’s used primarily for input or output I’d call it `histogramInput()` or `histogramOuput()` instead.

- `histogramServer()` is the module server.

- `histogramApp()` creates a complete app for interactive experimentation and more formal testing.



## To take

Before writing a module is portant to define what you expect from that module and which process is related with it.

1. Document your modules using roxygen2 syntax.

![](images/19-modules/01-document.png)

2. Using reactive values as input.

![](images/19-modules/02-reactive-as-input.png)

3. Static inputs



## note about golem {-}

golem works hard to encourage you to use modules in all your apps. 
The Think-R team offers a slightly different set of conventions than the ones Hadley advocates. 

* Mastering Shiny approach: `histogramUI` and `histogramServer`
* `golem` approach: `mod_histogram_ui` and `mod_histogram_server`

```{r golem-demo, eval=FALSE}
golem::module_template("test", "test.R", export = TRUE)
```

## Case study -- modules to make a histogram

the first exercise transforms this: 

```{r eval = FALSE}
ui <- fluidPage(
  selectInput("var", "Variable", names(mtcars)),
  numericInput("bins", "bins", 10, min = 1),
  plotOutput("hist")
)
server <- function(input, output, session) {
  data <- reactive(mtcars[[input$var]])
  output$hist <- renderPlot({
    hist(data(), breaks = input$bins, main = input$var)
  }, res = 96)
}

shinyApp(ui = ui, server = server)
```

to this:

```{r eval=FALSE}
histogramUI <- function(id) {
  tagList(
    selectInput(NS(id, "var"), "Variable", choices = names(mtcars)),
    numericInput(NS(id, "bins"), "bins", value = 10, min = 1),
    plotOutput(NS(id, "hist"))
  )
}

histogramServer <- function(id) {
  moduleServer(id, function(input, output, session) {
    data <- reactive(mtcars[[input$var]])
    output$hist <- renderPlot({
      hist(data(), breaks = input$bins, main = input$var)
    }, res = 96)
  })
}
```


```{r eval=FALSE}
histogramApp <- function() {
  ui <- fluidPage(
    histogramUI("hist1")
  )
  server <- function(input, output, session) {
    histogramServer("hist99")
  }
  shinyApp(ui, server)  
}
```


## Case study: histogram with two modules

```{r eval = FALSE}
library(shiny)

# define the dataset input ----------------
# This is interesting, the function takes one id variable and works with that at the end
datasetInput <- function(id, filter = NULL) {
  names <- ls("package:datasets")
  if (!is.null(filter)) {
    data <- lapply(names, get, "package:datasets")
    names <- names[vapply(data, filter, logical(1))]
  }
  
  selectInput(NS(id, "dataset"), "Pick a dataset", choices = names)
}

# server function returns a reactive
datasetServer <- function(id) {
  moduleServer(id, function(input, output, session) {
    # last thing returned
    reactive(get(input$dataset, "package:datasets")) # gotta be a reactive
  })
}

# selectVar module --------------------

find_vars <- function(data, filter) {
  names(data)[vapply(data, filter, logical(1))]
}


# id is the only thing linking the two parts, Input and Server
# This module creates, within namespace `id`, the reactive input var_they_wants
selectVarInput <- function(id) {
  selectInput(NS(id, "var_they_wants"), "Variable", choices = NULL) 
}


selectVarServer <- function(id, data_chosen, filter = is.numeric) {
  moduleServer(id, function(input, output, session) {
    # WHEN the data changes -- that is, when the reactive value data() changes here...
    observeEvent(data_chosen(), {
      # ... THEN you should update Select Input with the numeric columns of the new dataframe
      updateSelectInput(session, "var_they_wants", choices = find_vars(data_chosen(), filter))
      ## NOTE this updating happens WIHTIN the namespace `id`.
      #### var_they_wants is updated with the LIST OF VARS THEY MIGHT WANT
    })
    # input$var_they_wants -- 
    # note that in the server function selectVarServer is called with the namespace id
    # once again returning the last thing and its reactive
    
    list(
      name = reactive(input$var_they_wants),
      value = reactive(data_chosen()[[input$var_they_wants]])
    )
  })
}


```

Finally a third module to generate the histogram:

```{r eval = FALSE}
histogramOutput <- function(id) {
  tagList(
    numericInput(NS(id, "bins"), "bins", 10, min = 1, step = 1),
    plotOutput(NS(id, "hist"))
  )
}

histogramOutput("foobar")
# you can see where the input id is definied! 
```

I find it interesting to see how the module id is added to each component id in the HTML:

```html
<div class="form-group shiny-input-container">
  <label class="control-label" id="ff-bins-label" for="ff-bins">bins</label>
  <input id="ff-bins" type="number" class="form-control" value="10" min="1" step="1"/>
</div>
<div id="ff-hist" class="shiny-plot-output" style="width:100%;height:400px;"></div>
```

```{r eval = FALSE}
histogramServer <- function(id, x, title = reactive("Histogram")) {
  # we like these checks at the beginning because they make better error messages
  stopifnot(is.reactive(x))
  stopifnot(is.reactive(title))
  
  moduleServer(id, function(input, output, session) {   
    # browser()
    output$hist <- renderPlot({
      # whoa req is interesting.. checks for "truthiness". but why the is.numeric first???
      req(is.numeric(x()))
      # generate a req error just to see
      # req(is.character(x()))
      # input bins is assumed to be in the same namespace???
      main <- paste0(title(), " [", input$bins, "]")
      
      hist(x(), breaks = input$bins, main = main)
    },
    # neat little point to control res of plot!
    res = 96)
  })
}

```

```{r eval = FALSE}
# note that there is nothing in the code YET that makes these two things go together! except the name!

histogramApp <- function() {
  ui <- fluidPage(
    sidebarLayout(
      sidebarPanel(
        datasetInput("data", is.data.frame),
        selectVarInput("var"),
      ),
      mainPanel(
        histogramOutput("hist")    
      )
    )
  )
  
  server <- function(input, output, session) {
    data <- datasetServer("data")
    # reactive output captured here!! 
    x <- selectVarServer("var", data)

    histogramServer("hist", x = x$value, title = x$name)
  }
  shinyApp(ui, server)
} 
histogramApp()
```

## Links to examples

Two versions of a simple app based on Tidy Tuesday data:
* [Shiny dashboard](https://github.com/jakelawlor/Volcano_Shiny_App)
* [golem with modules](https://github.com/bios2/shiny_volcano_golem)


## Meeting Videos

### Cohort 1

`r knitr::include_url("https://www.youtube.com/embed/KrBuLk4VfsU")`

<details>
  <summary> Meeting chat log </summary>
  
```
00:03:51	Federica Gazzelloni:	hello!
00:13:14	Andrew MacDonald (he/him):	https://github.com/jakelawlor/Volcano_Shiny_App
00:13:30	Andrew MacDonald (he/him):	https://github.com/bios2/shiny_volcano_golem
01:03:04	Layla Bouzoubaa:	Everyone, I need to hop off for a 1pm!! Thanks Andrew <- NS(MacDonald)!!
01:03:18	Andrew MacDonald (he/him):	yw!
01:03:47	Federica Gazzelloni:	great!
```
</details>

### Cohort 2

`r knitr::include_url("https://www.youtube.com/embed/5YmZiyVgUeg")`

`r knitr::include_url("https://www.youtube.com/embed/BTpK8lan97E")`

<details>
  <summary> Meeting chat log </summary>
  
```
00:43:20	Kevin Gilds:	https://github.com/bios2/shiny_volcano_golem
```
</details>


### Cohort 3

`r knitr::include_url("https://www.youtube.com/embed/O1Fe_IHWcS0")`

<details>
  <summary>Meeting chat log</summary>
```
00:52:06	Oluwafemi Oyedele:	https://shiny.rstudio.com/articles/modules.html
00:52:25	Oluwafemi Oyedele:	https://engineering-shiny.org/structuring-project.html
```
</details>


### Cohort 4

`r knitr::include_url("https://www.youtube.com/embed/f5nWPY3jYAM")`

<details>
  <summary>Meeting chat log</summary>
```
00:06:51	Lydia Gibson:	Hello
00:08:33	Trevin Flickinger:	https://www.youtube.com/watch?v=F6I_jXPWFBk
00:09:42	Trevin Flickinger:	https://engineering-shiny.org/structuring-project.html?q=module#using-shiny-modules
00:10:34	Lydia Gibson:	I attended Shiny conf 2023 but didn’t get to attend a lot of talk
00:48:53	Matthew Efoli:	interesting!
```
</details>


### Cohort 5

`r knitr::include_url("https://www.youtube.com/embed/URL")`

<details>
  <summary>Meeting chat log</summary>
```
LOG
```
</details>
